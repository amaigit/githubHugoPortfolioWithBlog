<!doctype html><html lang=en><head><title>Posts</title><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><link rel=stylesheet href=/githubHugoPortfolioWithBlog/application.d1785a836403ea5674ce9266182089ba8e7605386dd4df10bc5916abdf6bdd88.css integrity="sha256-0Xhag2QD6lZ0zpJmGCCJuo52BTht1N8QvFkWq99r3Yg="><link rel=alternate type=application/rss+xml href=https://amaigit.github.io/githubHugoPortfolioWithBlog/posts/index.xml title="Portfolio di Andrea Morosati"><meta property="og:title" content="Portfolio di Andrea Morosati"><meta property="og:type" content="website"><meta property="og:description" content><meta property="og:image" content="/githubHugoPortfolioWithBlog/"><meta property="og:url" content="https://amaigit.github.io/githubHugoPortfolioWithBlog/"><script integrity="sha256-DO4ugzEwhTW1Id1UIWn0gUJWaebCYOypeTit6LW4QB4=">let theme=localStorage.getItem("theme-scheme")||localStorage.getItem("darkmode:color-scheme")||"light";theme==="system"&&(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?theme="dark":theme="light"),document.documentElement.setAttribute("data-theme",theme)</script></head><body class="type-posts kind-section" data-bs-spy=scroll data-bs-target=#TableOfContents data-bs-offset=80><div class="container-fluid bg-secondary wrapper"><nav class="navbar navbar-expand-xl top-navbar shadow" id=top-navbar><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button>
<i data-feather=sidebar></i>
</button>
<a class=navbar-brand href=/githubHugoPortfolioWithBlog>Portfolio di Andrea Morosati</a>
<button class="navbar-toggler navbar-light" id=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#top-nav-items aria-label=menu>
<i data-feather=menu></i></button><div class="collapse navbar-collapse dynamic-navbar" id=top-nav-items><ul class="nav navbar-nav ms-auto"><li class=nav-item><a class=nav-link href=/githubHugoPortfolioWithBlog#home>Home</a></li></ul></div></div></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/githubHugoPortfolioWithBlog/search><input type=text name=keyword placeholder=Search data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/githubHugoPortfolioWithBlog/posts data-filter=all>Posts</a></li><div class=subtree></div></ul></div></div></div></section><section class=content-section id=content-section><div class="content container-fluid" id=content><div class="container-fluid post-card-holder" id=post-card-holder><div class=post-card><div class=card><div class=card-head><a href=/githubHugoPortfolioWithBlog/blog/2025/01/costruire-microservizi-in-go-best-practices-e-pattern/ class=post-card-link><img class=card-img-top src=/githubHugoPortfolioWithBlog/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/githubHugoPortfolioWithBlog/blog/2025/01/costruire-microservizi-in-go-best-practices-e-pattern/ class=post-card-link><h5 class=card-title>Costruire Microservizi in Go: Best Practices e Pattern</h5><p class="card-text post-summary">Costruire Microservizi in Go: Best Practices e Pattern Go è diventato uno dei linguaggi preferiti per lo sviluppo di microservizi grazie alla sua semplicità, performance e supporto nativo per la concorrenza. In questo articolo condivido le mie esperienze e best practices per costruire microservizi robusti e scalabili.
Perché Go per i Microservizi? Vantaggi Principali Performance: Compilazione nativa e gestione efficiente della memoria Concorrenza: Goroutines e channels per gestione asincrona Semplicità: Sintassi pulita e standard library completa Deployment: Binari singoli, facile containerizzazione Architettura di Base Struttura del Progetto microservice/ ├── cmd/ │ └── server/ │ └── main.go ├── internal/ │ ├── handler/ │ ├── service/ │ ├── repository/ │ └── middleware/ ├── pkg/ │ ├── database/ │ ├── config/ │ └── logger/ ├── api/ │ └── proto/ ├── docker/ └── go.mod Pattern Architetturali 1. Clean Architecture // internal/handler/user.go type UserHandler struct { userService service.UserService } func (h *UserHandler) CreateUser(c *gin.Context) { var user domain.User if err := c.ShouldBindJSON(&amp;user); err != nil { c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return } result, err := h.userService.Create(c.Request.Context(), user) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return } c.JSON(http.StatusCreated, result) } 2. Dependency Injection // cmd/server/main.go func main() { // Configurazione config := config.Load() // Database db := database.NewConnection(config.Database) // Repository userRepo := repository.NewUserRepository(db) // Service userService := service.NewUserService(userRepo) // Handler userHandler := handler.NewUserHandler(userService) // Router router := gin.Default() router.POST("/users", userHandler.CreateUser) router.Run(":8080") } Best Practices 1. Gestione Configurazione // pkg/config/config.go type Config struct { Server ServerConfig `mapstructure:"server"` Database DatabaseConfig `mapstructure:"database"` Redis RedisConfig `mapstructure:"redis"` } type ServerConfig struct { Port string `mapstructure:"port"` Timeout int `mapstructure:"timeout"` } func Load() *Config { viper.SetConfigName("config") viper.SetConfigType("yaml") viper.AddConfigPath(".") if err := viper.ReadInConfig(); err != nil { log.Fatal("Error reading config file", err) } var config Config if err := viper.Unmarshal(&amp;config); err != nil { log.Fatal("Error unmarshaling config", err) } return &amp;config } 2. Logging Strutturato // pkg/logger/logger.go import "go.uber.org/zap" func NewLogger() *zap.Logger { config := zap.NewProductionConfig() config.OutputPaths = []string{"stdout", "logs/app.log"} logger, err := config.Build() if err != nil { log.Fatal("Error creating logger", err) } return logger } // Utilizzo logger.Info("User created successfully", zap.String("user_id", user.ID), zap.String("email", user.Email), ) 3. Middleware per Observability // internal/middleware/logging.go func LoggingMiddleware(logger *zap.Logger) gin.HandlerFunc { return func(c *gin.Context) { start := time.Now() c.Next() duration := time.Since(start) logger.Info("Request processed", zap.String("method", c.Request.Method), zap.String("path", c.Request.URL.Path), zap.Int("status", c.Writer.Status()), zap.Duration("duration", duration), ) } } Comunicazione tra Servizi 1. REST API // internal/client/user_client.go type UserClient struct { baseURL string client *http.Client } func (c *UserClient) GetUser(id string) (*User, error) { resp, err := c.client.Get(fmt.Sprintf("%s/users/%s", c.baseURL, id)) if err != nil { return nil, err } defer resp.Body.Close() var user User if err := json.NewDecoder(resp.Body).Decode(&amp;user); err != nil { return nil, err } return &amp;user, nil } 2. gRPC // api/proto/user.proto syntax = "proto3"; package user; service UserService { rpc GetUser(GetUserRequest) returns (User); rpc CreateUser(CreateUserRequest) returns (User); } message User { string id = 1; string email = 2; string name = 3; } Testing 1. Unit Tests // internal/service/user_service_test.go func TestUserService_Create(t *testing.T) { // Setup mockRepo := &amp;mocks.UserRepository{} service := NewUserService(mockRepo) user := domain.User{ Email: "test@example.com", Name: "Test User", } mockRepo.On("Create", mock.Anything, user).Return(&amp;user, nil) // Execute result, err := service.Create(context.Background(), user) // Assert assert.NoError(t, err) assert.Equal(t, user.Email, result.Email) mockRepo.AssertExpectations(t) } 2. Integration Tests // tests/integration/user_test.go func TestUserAPI_CreateUser(t *testing.T) { // Setup test server router := setupTestRouter() server := httptest.NewServer(router) defer server.Close() // Test data userData := map[string]interface{}{ "email": "test@example.com", "name": "Test User", } jsonData, _ := json.Marshal(userData) // Execute request resp, err := http.Post(server.URL+"/users", "application/json", bytes.NewBuffer(jsonData)) assert.NoError(t, err) assert.Equal(t, http.StatusCreated, resp.StatusCode) } Deployment e Containerizzazione Dockerfile # Dockerfile FROM golang:1.21-alpine AS builder WORKDIR /app COPY go.mod go.sum ./ RUN go mod download COPY . . RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main ./cmd/server FROM alpine:latest RUN apk --no-cache add ca-certificates WORKDIR /root/ COPY --from=builder /app/main . COPY --from=builder /app/config ./config EXPOSE 8080 CMD ["./main"] Docker Compose # docker-compose.yml version: '3.8' services: user-service: build: . ports: - "8080:8080" environment: - DB_HOST=postgres - REDIS_HOST=redis depends_on: - postgres - redis postgres: image: postgres:15 environment: POSTGRES_DB: users POSTGRES_USER: user POSTGRES_PASSWORD: password volumes: - postgres_data:/var/lib/postgresql/data redis: image: redis:7-alpine ports: - "6379:6379" volumes: postgres_data: Monitoring e Observability 1. Health Checks // internal/handler/health.go func HealthCheck(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ "status": "healthy", "timestamp": time.Now().Unix(), "version": "1.0.0", }) } 2. Metrics con Prometheus // pkg/metrics/metrics.go import "github.com/prometheus/client_golang/prometheus" var ( httpRequestsTotal = prometheus.NewCounterVec( prometheus.CounterOpts{ Name: "http_requests_total", Help: "Total number of HTTP requests", }, []string{"method", "endpoint", "status"}, ) httpRequestDuration = prometheus.NewHistogramVec( prometheus.HistogramOpts{ Name: "http_request_duration_seconds", Help: "HTTP request duration in seconds", }, []string{"method", "endpoint"}, ) ) Conclusione Costruire microservizi in Go richiede attenzione all&rsquo;architettura, testing e observability. Le best practices presentate in questo articolo forniscono una base solida per sviluppare servizi robusti e scalabili.</p></a></div><div class=card-footer><span class=float-start>Sunday, January 26, 2025
</span><a href=/githubHugoPortfolioWithBlog/blog/2025/01/costruire-microservizi-in-go-best-practices-e-pattern/ class="float-end btn btn-outline-info btn-sm">Read</a></div></div></div><div class=post-card><div class=card><div class=card-head><a href=/githubHugoPortfolioWithBlog/blog/2025/01/il-mio-primo-dev-log-avvio-del-portfolio-con-hugo-e-toha/ class=post-card-link><img class=card-img-top src=/githubHugoPortfolioWithBlog/images/default-hero.jpg alt="Hero Image"></a></div><div class=card-body><a href=/githubHugoPortfolioWithBlog/blog/2025/01/il-mio-primo-dev-log-avvio-del-portfolio-con-hugo-e-toha/ class=post-card-link><h5 class=card-title>Il Mio Primo Dev Log: Avvio del Portfolio con Hugo e Toha</h5><p class="card-text post-summary">Il Mio Primo Dev Log: Avvio del Portfolio con Hugo e Toha Benvenuti nel primo articolo di questo diario di sviluppo! Oggi ho iniziato a lavorare sul Portfolio con Hugo e Toha, un progetto che mi accompagnerà nel documentare il mio percorso professionale e condividere esperienze tecniche.
Perché Hugo e Toha? Ho scelto Hugo come generatore di siti statici per diversi motivi:
Performance: Siti veloci e ottimizzati Semplicità: Setup rapido e configurazione intuitiva Flessibilità: Ampia personalizzazione possibile Community: Ottima documentazione e supporto Il tema Toha mi ha conquistato per:</p></a></div><div class=card-footer><span class=float-start>Sunday, January 26, 2025
</span><a href=/githubHugoPortfolioWithBlog/blog/2025/01/il-mio-primo-dev-log-avvio-del-portfolio-con-hugo-e-toha/ class="float-end btn btn-outline-info btn-sm">Read</a></div></div></div></div><div class=paginator></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-start"><div class="col-md-4 col-sm-12"><h5>Navigation</h5></div><div class="col-md-4 col-sm-12"><p>Stay up to date with email notification</p><form method=post action=https://blogtrottr.com><div class=form-group><input type=email class=form-control name=btr_email placeholder="Enter email"><br><input type=hidden name=btr_url value=https://amaigit.github.io/githubHugoPortfolioWithBlog//index.xml>
<input type=hidden name=schedule_type value=1>
<small id=emailHelp class="form-text text-muted">By entering your email address, you agree to receive the newsletter of this website.</small>
<button type=submit class="btn btn-info"> Submit</button></div></form></div></div></div><hr><div class=container><div class="row text-start"><div class=col-md-4><a id=theme href=https://github.com/hugo-toha/toha target=_blank rel=noopener><img src=/githubHugoPortfolioWithBlog/images/theme-logo_hu_b3360284c55cf72d.png alt="Toha Theme Logo">
Toha</a></div><div class="col-md-4 text-center">© 2025 Copyright.</div><div class="col-md-4 text-end"><a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Powered by
<img src=/githubHugoPortfolioWithBlog/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/githubHugoPortfolioWithBlog/application.6bd448faa7d412c73e4646e4080b1601e60b504349a40c7778d3e05c7774047f.js integrity="sha256-a9RI+qfUEsc+RkbkCAsWAeYLUENJpAx3eNPgXHd0BH8=" defer></script></body></html>